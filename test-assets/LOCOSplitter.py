#    "$Name:  $";
#    "$Header:  $";
#=============================================================================
#
# file :        LOCOSplitter.py
#
# description : Python source for the LOCOSplitter and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                LOCOSplitter are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author:  srubio@cells.es
#
# $Revision:  $
#
# $Log:  $
#
# copyleft :    ALBA Synchrotron
#               www.cells.es
#               BCN
#
#=============================================================================
#          This file is generated by POGO
#    (Program Obviously used to Generate tango Object)
#
#         (c) - Controls Group - ALBA
#=============================================================================
#


import PyTango
import sys
import inspect

from VacuumController.SerialVacuumDevice import *


#==================================================================
#   LOCOSplitter Class Description:
#
#         Device Server to read current from the LOCO Ion Pump Splitter Box.
#
#==================================================================
#     Device States Description:
#
#   DevState.ON :
#   DevState.OFF :
#   DevState.ALARM :
#   DevState.FAULT :
#   DevState.INIT :
#==================================================================


class LOCOSplitter(PyTango.Device_3Impl):

#--------- Add you global variables here --------------------------

    ModuleAdresses = []
    
    def UnpackFreq(self, cadena):
        """ This method unpacks the frequency information from the string sended by the device
            The String is: '.lcxxx:aaaaaaaa:bbbbbbbb:cccccccc:dddddddd:eee:fff\r'
            xxx: module address
            aaa: 1s frequency
            bbb: ten second average
            ccc: maximum freq between reads
            ddd: minimum freq between reads
            eee: alarm status
            fff: module temperature
            """
        print "The string received is :", cadena
        freqs = cadena.split(':')
        return float(freqs[1])
        
    def writeCommand(self, comm, argin):
        """ This method provides a generic function for executing write-only commands """
        try:
            self.SVD.addComm(argin,argin)
        except Exception, e:
            print str(e)
            self.set_status(self.get_status())
            raise DevFailed, ('Exception in ',comm,'()')
    
    def readCommand(self, comm, _type):
        """
        Type          No. of Bytes.         Description 
        Read             1 .        ?. (3Fh3) performs reads on the Dual controller
        Status             1 .        0. (30h) = false = off,.1. (31h) = true = on 5
        Integer         5 .        xxxxx. represented in BCD4 on 5 digits (always positive)
        BitField         8         Like the integer type, but with meanings associated to the number.s single bits
        Exponential         7         .x.xEsxx. where x is BCD digits, E is the 45h character and s is the (.+. o .-. sign
        String             n         Sequence of na  characters included within the 20h and 7Fh range
        """
        result=""
        try:
            result = self.SVD.getComm(self.HVComms[comm])
            ##OJORL! The 3 first characters are discarded (not 4). The initial '>' is discarded by the SVD class.
            print '\tData(',(len(result)-3),',',result,') readed: "',result[3:],'"'
            result=result[3:]
            if _type == type(1.0):
                return float(result)
            elif _type == type(1):
                return int(result)
            elif _type == type('caligari'):
                return result
            elif not len(result):
                return None
            elif result == '0':
                return False
            else:
                return result #boolean True
        except Exception, e:
            print str(e)
            self.set_status('\nLast exception: '+str(e))
            PyTango.Except.throw_exception("PyTango VarianDUAL.readCommand Exception",str(e),str(e))    
            #PyTango.Except.re_throw_exception(e,"VarianDUAL","read_"+comm+"()",result)

#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_3Impl.__init__(self,cl,name)
        LOCOSplitter.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        print "[Device delete_device method] for device",self.get_name()


#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        print "In ", self.get_name(), "::init_device()"
        self.set_state(PyTango.DevState.ON)
        self.get_device_properties(self.get_device_class())
        
        try:
            if not self.Refresh: # or self.Refresh<1:
                print 'Refresh attribute does not exists!'
                self.Refresh=1
        except Exception, e:
            print str(e)
            self.Refresh=1
        print 'Refresh pause between connections set to ',self.Refresh,' seconds.'
        
        #print 'COMMAND:',self.packMultiGauge(1, 31, 'mira per on'),';'
        self.HVComms = {}
        # READ COMMANDS
        self.HVComms['F1'] ='lc011\n'
        self.HVComms['F2'] ='lc012\n'
        self.HVComms['F3'] ='lc013\n'
        self.HVComms['F4'] ='lc014\n'
        self.HVComms['F5'] ='lc015\n'
        
        if len(self.SerialLine):
            #self.SVD=SerialVacuumDevice(tangoDevice=self.SerialLine,period=self.Refresh,timewait=0.2)
            self.SVD=SerialVacuumDevice(tangoDevice=self.SerialLine,period=0.,wait=0.1)
            #VARIAN DUAL PROTOCOL: MultiGauge Compatible (No Checksum)
            for key in self.HVComms.keys():
                val = self.HVComms[key]
                print val
                self.SVD.addComm(val)
                self.SVD.setPolledComm(val,1.)
            self.SVD.start() #self.SVD.updateThread.start()
        else:
            raise RuntimeError, str('SerialLine property requires a value!')
        
        print "Device Server ", self.get_name(), ' waiting for request.'
        self.ChannelState=[]
        for i in range(5): self.ChannelState.append('Unknown')
        
        self.set_state(DevState.ON)

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        print "In ", self.get_name(), "::always_excuted_hook()"
        
        if self.SVD.init == False:
            self.set_state(DevState.INIT)
        elif self.SVD.errors>=self.SVD.comms:
            self.set_state(DevState.FAULT)
        else:
            self.set_state(DevState.ON)
        
        status = 'The Device is '+str(self.get_state())+'\n'    
        if len(self.SVD.lastrecv):
            status = status+'Last communication received at '+self.SVD.lasttime+': "'+self.SVD.lastrecv+'"\n'
        if self.SVD.errors:
            status = status+str(self.SVD.errors)+' communication errors\n'
        self.set_status(status)

#==================================================================
#
#    LOCOSplitter read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        print "In ", self.get_name(), "::read_attr_hardware()"


#------------------------------------------------------------------
#    Read IP1 attribute
#------------------------------------------------------------------
    def read_IP1(self, attr):
        print "In ", self.get_name(), "::read_IP1()"
        
        #    Add your own code here
        
        attr_IP1_read = self.UnpackFreq(self.readCommand('F1',type('str')))
        attr.set_value(attr_IP1_read)


#------------------------------------------------------------------
#    Read IP2 attribute
#------------------------------------------------------------------
    def read_IP2(self, attr):
        print "In ", self.get_name(), "::read_IP2()"
        
        #    Add your own code here
        
        attr_IP2_read = self.UnpackFreq(self.readCommand('F2',type('str')))
        attr.set_value(attr_IP2_read)


#------------------------------------------------------------------
#    Read IP3 attribute
#------------------------------------------------------------------
    def read_IP3(self, attr):
        print "In ", self.get_name(), "::read_IP3()"
        
        #    Add your own code here
        
        attr_IP3_read = self.UnpackFreq(self.readCommand('F3',type('str')))
        attr.set_value(attr_IP3_read)


#------------------------------------------------------------------
#    Read IP4 attribute
#------------------------------------------------------------------
    def read_IP4(self, attr):
        print "In ", self.get_name(), "::read_IP4()"
        
        #    Add your own code here
        
        attr_IP4_read = self.UnpackFreq(self.readCommand('F4',type('str')))
        attr.set_value(attr_IP4_read)


#------------------------------------------------------------------
#    Read IP5 attribute
#------------------------------------------------------------------
    def read_IP5(self, attr):
        print "In ", self.get_name(), "::read_IP5()"
        
        #    Add your own code here
        
        attr_IP5_read = self.UnpackFreq(self.readCommand('F5',type('str')))
        attr.set_value(attr_IP5_read)


#------------------------------------------------------------------
#    Read P1 attribute
#------------------------------------------------------------------
    def read_P1(self, attr):
        print "In ", self.get_name(), "::read_P1()"
        
        #    Add your own code here
        
        attr_P1_read = 1.0
        attr.set_value(attr_P1_read)


#------------------------------------------------------------------
#    Read P2 attribute
#------------------------------------------------------------------
    def read_P2(self, attr):
        print "In ", self.get_name(), "::read_P2()"
        
        #    Add your own code here
        
        attr_P2_read = 1.0
        attr.set_value(attr_P2_read)


#------------------------------------------------------------------
#    Read P3 attribute
#------------------------------------------------------------------
    def read_P3(self, attr):
        print "In ", self.get_name(), "::read_P3()"
        
        #    Add your own code here
        
        attr_P3_read = 1.0
        attr.set_value(attr_P3_read)


#------------------------------------------------------------------
#    Read P5 attribute
#------------------------------------------------------------------
    def read_P5(self, attr):
        print "In ", self.get_name(), "::read_P5()"
        
        #    Add your own code here
        
        attr_P5_read = 1.0
        attr.set_value(attr_P5_read)


#------------------------------------------------------------------
#    Read Frequencies1s attribute
#------------------------------------------------------------------
    def read_Frequencies1s(self, attr):
        print "In ", self.get_name(), "::read_Frequencies1s()"
        
        #    Add your own code here
        
        attr_Frequencies1s_read = [1.0]
        attr_Frequencies1s_read[0] = self.UnpackFreq(self.readCommand('F1',type('str')))
        attr_Frequencies1s_read[1] = self.UnpackFreq(self.readCommand('F2',type('str')))
        attr_Frequencies1s_read[2] = self.UnpackFreq(self.readCommand('F3',type('str')))
        attr_Frequencies1s_read[3] = self.UnpackFreq(self.readCommand('F4',type('str')))
        attr_Frequencies1s_read[4] = self.UnpackFreq(self.readCommand('F5',type('str')))
        attr.set_value(attr_Frequencies1s_read, 1)


#------------------------------------------------------------------
#    Read Frequencies10s attribute
#------------------------------------------------------------------
    def read_Frequencies10s(self, attr):
        print "In ", self.get_name(), "::read_Frequencies10s()"
        
        #    Add your own code here
        
        attr_Frequencies10s_read = [1.0]
        attr.set_value(attr_Frequencies10s_read, 1)



#==================================================================
#
#    LOCOSplitter command methods
#
#==================================================================

#==================================================================
#
#    LOCOSplitterClass class definition
#
#==================================================================
class LOCOSplitterClass(PyTango.PyDeviceClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'SerialLine':
            [PyTango.DevString,
            "SerialLine device server used to communicate with the LOCO splitter",
            [] ],
        'FreqCalibration':
            [PyTango.DevVarDoubleArray,
            "C factor to convert from frequency to current: \n\nI = 10^[(f-660)/80] / C\n\nIf the device has been pre-calibrated this value is supposed to be 1",
            [ 1 ] ],
        'PumpK':
            [PyTango.DevVarDoubleArray,
            "Used to calculate the pressure using the formula:\n\nI = K*p^n",
            [] ],
        'PumpN':
            [PyTango.DevVarDoubleArray,
            "Used to calculate the presure using the formula:\n\nI = K*p^n",
            [] ],
        }


    #    Command definitions
    cmd_list = {
        }


    #    Attribute definitions
    attr_list = {
        'IP1':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'format':"scientific;uppercase;setprecision(3)",
                'description':"Current from the Ion Pump",
            } ],
        'IP2':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'format':"scientific;uppercase;setprecision(3)",
                'description':"Current from the Ion Pump",
            } ],
        'IP3':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'format':"scientific;uppercase;setprecision(3)",
                'description':"Current from the Ion Pump",
            } ],
        'IP4':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'format':"scientific;uppercase;setprecision(3)",
                'description':"Current from the Ion Pump",
            } ],
        'IP5':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'format':"scientific;uppercase;setprecision(3)",
                'description':"Current from the Ion Pump",
            } ],
        'P1':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'format':"scientific;uppercase;setprecision(3)",
                'description':"Pressure from the Ion Pump",
            } ],
        'P2':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'format':"scientific;uppercase;setprecision(3)",
                'description':"Pressure from the Ion Pump",
            } ],
        'P3':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'format':"scientific;uppercase;setprecision(3)",
                'description':"Pressure from the Ion Pump",
            } ],
        'P5':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'format':"scientific;uppercase;setprecision(3)",
                'description':"Pressure from the Ion Pump",
            } ],
        'Frequencies1s':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 16],
            {
                'description':"Frequencies integrated in the last 1s period",
            } ],
        'Frequencies10s':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ, 16],
            {
                'description':"Frequencies readed in the last 10s period",
            } ],
        }


#------------------------------------------------------------------
#    LOCOSplitterClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.PyDeviceClass.__init__(self, name)
        self.set_type(name);
        print "In LOCOSplitterClass  constructor"

#==================================================================
#
#    LOCOSplitter class main method
#
#==================================================================
if __name__ == '__main__':
    try:
        py = PyTango.PyUtil(sys.argv)
        py.add_TgClass(LOCOSplitterClass,LOCOSplitter,'LOCOSplitter')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e
